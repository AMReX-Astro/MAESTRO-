

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>MAESTROeX Architecture &mdash; MAESTROeX 19.04
 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"TeX": {"Macros": {"rhozero": "{\\rho_0}", "pizero": "{\\pi_0}", "pizeroone": "{\\pi_0^{(1)}}", "pizerotwo": "{\\pi_0^{(2)}}", "gammabar": "{\\overline{\\Gamma}_1}", "ptl": "{\\partial}", "eb": "{{\\bf e}}", "fb": "{{\\bf f}}", "ib": "{{\\bf i}}", "Ub": "{{\\bf U}}", "Vb": "{{\\bf V}}", "xb": "{{\\bf x}}", "ut": "{{\\tilde{u}}}", "vt": "{{\\tilde{v}}}", "wt": "{{\\tilde{w}}}", "Ubt": "{\\widetilde{\\Ub}}", "edge": "{{\\rm EDGE}}", "mac": "{{\\rm MAC}}", "trans": "{{\\rm TRANS}}", "nablab": "{\\mathbf{\\nabla}}", "cdotb": "{\\mathbf{\\cdot}}", "half": "{\\frac{1}{2}}", "myhalf": "{\\frac{1}{2}}", "nph": "{{n + \\myhalf}}", "nmh": "{{n - \\myhalf}}", "Hext": "{{H_{\\rm ext}}}", "Hnuc": "{{H_{\\rm nuc}}}", "kth": "{k_{\\rm th}}", "pred": "{{\\rm pred}}", "Sbar": "{\\overline{S}}", "inp": "{\\mathrm{in}}", "initp": "{\\mathrm{init}}", "outp": "{\\mathrm{out}}", "uadv": "{\\widetilde{\\mathbf{U}}^{\\mathrm{ADV}}}", "uadvone": "{\\widetilde{\\mathbf{U}}^{\\mathrm{ADV},\\star}}", "uadvonedag": "{\\Ubt^{\\mathrm{ADV},\\dagger,\\star}}", "uadvtwo": "{\\widetilde{\\mathbf{U}}^{\\mathrm{ADV}}}", "uadvtwodag": "{\\Ubt^{\\mathrm{ADV},\\dagger}}", "uadvsdcstar": "{\\mathbf{U}^{\\mathrm{ADV},\\star}}", "uadvsdcpred": "{\\mathbf{U}^{\\mathrm{ADV},\\mathrm{pred}}}", "uadvsdc": "{\\mathbf{U}^{\\mathrm{ADV}}}", "dt": "{\\Delta t}", "dr": "{\\Delta r}", "etarho": "{\\eta_{\\rho}}", "etarhoec": "{\\etarho^{\\rm ec}}", "etarhocc": "{\\etarho^{\\rm cc}}", "etarhoflux": "{\\etarho^{\\rm flux}}", "divetarho": "{\\nabla\\cdot(\\etarho\\eb_r)}", "ow": "{\\overline{w}_0}", "dw": "{\\delta w_0}", "thalf": "{\\frac{3}{2}}", "rhop": "{{\\rho^{\\prime}}}", "omegadot": "{\\dot{\\omega}}", "er": "{\\mathbf{e}_r}", "ex": "{\\mathbf{e}_x}", "ey": "{\\mathbf{e}_y}", "ez": "{\\mathbf{e}_z}", "Omegab": "{{\\bf \\Omega}}", "rb": "{{\\bf r}}", "boxtype": "{{\\tt box\\/}}", "fab": "{{\\tt fab\\/}}", "multifab": "{{\\tt multifab\\/}}", "boxarray": "{{\\tt boxarray\\/}}", "mlboxarray": "{{\\tt ml\\_boxarray\\/}}", "layout": "{{\\tt layout\\/}}", "mllayout": "{{\\tt ml\\_layout\\/}}", "bctower": "{{\\tt bc\\_tower\\/}}", "bclevel": "{{\\tt bc\\_level\\/}}", "mgtower": "{{\\tt mg\\_tower\\/}}", "bndryreg": "{{\\tt bndry\\_reg\\/}}", "runparam": ["{\\index{Runtime parameters!{\\tt #1}}{\\tt #1}}", 1], "runparamidx": ["{\\index{Runtime parameters!{\\tt #1}}}", 1], "code": ["{\\index{Code reference!{\\tt #1}}{\\tt #1}}", 1], "codeidx": ["{\\index{Code reference!{\\tt #1}}}", 1], "otherindex": ["{\\index{#1!#2}}", 2], "fdamp": "{{f_\\mathrm{damp}}}"}}})</script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Runtime Parameters" href="param_intro.html" />
    <link rel="prev" title="Common Runtime Parameters" href="common_parameters.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> MAESTROeX
          

          
          </a>

          
            
            
              <div class="version">
                19.04

              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">MAESTROeX basics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="preface.html">Preface</a></li>
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Introduction to MAESTROeX</a></li>
<li class="toctree-l1"><a class="reference internal" href="flowchart.html">MAESTROeX Flowchart</a></li>
</ul>
<p class="caption"><span class="caption-text">Using MAESTROeX</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="problems.html">Problem Setups</a></li>
<li class="toctree-l1"><a class="reference internal" href="unit_tests.html">Unit Tests</a></li>
<li class="toctree-l1"><a class="reference internal" href="common_parameters.html">Common Runtime Parameters</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">MAESTROeX Architecture</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#maestro-basics">MAESTRO Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="#the-maestro-ecosystem">The MAESTRO ‘Ecosystem’</a></li>
<li class="toctree-l2"><a class="reference internal" href="#adding-a-new-problem">Adding A New Problem</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#the-gnumakefile">The GNUmakefile</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#handling-problem-specific-source-files">Handling Problem-Specific Source Files</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#defining-runtime-parameters">Defining Runtime Parameters</a></li>
<li class="toctree-l3"><a class="reference internal" href="#preparing-the-initial-model">Preparing the Initial Model</a></li>
<li class="toctree-l3"><a class="reference internal" href="#customizing-the-initialization">Customizing the Initialization</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#amrex-data-structures">AMReX Data Structures</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#box">box</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#common-operations-on-a-box">Common Operations on a box</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#boxarray-and-ml-boxarray">boxarray and ml_boxarray</a></li>
<li class="toctree-l3"><a class="reference internal" href="#layout-and-ml-layout">layout and ml_layout</a></li>
<li class="toctree-l3"><a class="reference internal" href="#fab">fab</a></li>
<li class="toctree-l3"><a class="reference internal" href="#multifab">multifab</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#working-with-multifabs">Working with multifabs</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#bc-tower">bc_tower</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#maestro-data-organization">MAESTRO Data Organization</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#s-multifabs-fluid-state">‘s’ multifabs (fluid state)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#u-multifabs-fluid-velocity">‘u’ multifabs (fluid velocity)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#umac-the-mac-velocity">umac (the MAC velocity)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#base-state-arrays">Base State Arrays</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#maestro-helper-modules">MAESTRO Helper Modules</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#average-module">average_module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#eos-module">eos_module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#fill-3d-module">fill_3d_module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#fundamental-constants-module">fundamental_constants_module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#geometry">geometry</a></li>
<li class="toctree-l3"><a class="reference internal" href="#network">network</a></li>
<li class="toctree-l3"><a class="reference internal" href="#probin-module">probin_module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#variables">variables</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#amrex-helper-modules">AMReX Helper Modules</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#amrex-constants">amrex_constants</a></li>
<li class="toctree-l3"><a class="reference internal" href="#parallel">parallel</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#sec-example-example-accessing-state-and-mac-data">[sec:example] Example: Accessing State and MAC Data</a></li>
<li class="toctree-l2"><a class="reference internal" href="#filling-ghostcells">Filling Ghostcells</a></li>
<li class="toctree-l2"><a class="reference internal" href="#boundary-conditions">Boundary Conditions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#multigrid">Multigrid</a></li>
<li class="toctree-l2"><a class="reference internal" href="#multilevel-and-refinement-criteria">Multilevel and Refinement Criteria</a></li>
<li class="toctree-l2"><a class="reference internal" href="#particles">Particles</a></li>
<li class="toctree-l2"><a class="reference internal" href="#regression-testing">Regression Testing</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="param_intro.html">Runtime Parameters</a></li>
<li class="toctree-l1"><a class="reference internal" href="initial_models.html">Initial Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="visualization.html">Visualization</a></li>
<li class="toctree-l1"><a class="reference internal" href="analysis.html">Analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="makefiles.html">MAESTROeX Build System</a></li>
<li class="toctree-l1"><a class="reference internal" href="managingjobs.html">Managing Jobs</a></li>
<li class="toctree-l1"><a class="reference internal" href="faq.html">Frequently Asked Questions</a></li>
</ul>
<p class="caption"><span class="caption-text">MAESTROeX technical details</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="lo_density.html">Low Density Cutoffs</a></li>
<li class="toctree-l1"><a class="reference internal" href="volume_discrepancy.html">Volume Discrepancy Factor</a></li>
<li class="toctree-l1"><a class="reference internal" href="eos_notes.html">Equation of State Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="networks.html">Reaction Networks</a></li>
<li class="toctree-l1"><a class="reference internal" href="eta.html">The Mixing Term, <span class="math notranslate nohighlight">\(\etarho\)</span></a></li>
<li class="toctree-l1"><a class="reference internal" href="eta.html#eta-flow-chart"><span class="math notranslate nohighlight">\(\eta\)</span> Flow Chart</a></li>
<li class="toctree-l1"><a class="reference internal" href="eta.html#computing-etarhoec-and-etarhocc">Computing <span class="math notranslate nohighlight">\(\etarhoec\)</span> and <span class="math notranslate nohighlight">\(\etarhocc\)</span></a></li>
<li class="toctree-l1"><a class="reference internal" href="eta.html#using-etarhoec">Using <span class="math notranslate nohighlight">\(\etarhoec\)</span></a></li>
<li class="toctree-l1"><a class="reference internal" href="eta.html#using-etarhocc">Using <span class="math notranslate nohighlight">\(\etarhocc\)</span></a></li>
<li class="toctree-l1"><a class="reference internal" href="pert.html">Interface State Details</a></li>
<li class="toctree-l1"><a class="reference internal" href="sdc.html">Spectral Deferred Corrections</a></li>
<li class="toctree-l1"><a class="reference internal" href="Godunov.html">Godunov Interface States</a></li>
<li class="toctree-l1"><a class="reference internal" href="mg.html">Multigrid</a></li>
<li class="toctree-l1"><a class="reference internal" href="rotation.html">Rotation in MAESTROeX</a></li>
<li class="toctree-l1"><a class="reference internal" href="spherical_basestate.html">Modifications for a Spherical Self-Gravitating Star</a></li>
<li class="toctree-l1"><a class="reference internal" href="planar_invsq_basestate.html">Modifications for a <span class="math notranslate nohighlight">\(1/r^2\)</span> Plane-Parallel Basestate</a></li>
<li class="toctree-l1"><a class="reference internal" href="thermo_notes.html">Notes on Thermodynamics</a></li>
<li class="toctree-l1"><a class="reference internal" href="beta0.html">Notes on <span class="math notranslate nohighlight">\(\beta_0\)</span></a></li>
<li class="toctree-l1"><a class="reference internal" href="enthalpy.html">Notes on Enthalpy</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="references.html">References</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">MAESTROeX</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>MAESTROeX Architecture</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/architecture.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="maestroex-architecture">
<h1>MAESTROeX Architecture<a class="headerlink" href="#maestroex-architecture" title="Permalink to this headline">¶</a></h1>
<div class="section" id="maestro-basics">
<h2>MAESTRO Basics<a class="headerlink" href="#maestro-basics" title="Permalink to this headline">¶</a></h2>
<p>MAESTRO models problems that are in tight hydrostatic equilibrium.
The fluid state is decomposed into a 1D radial base state that
describes the hydrostatic structure of the star or atmosphere, and a
2- or 3D Cartesian full state, that captures the departures from
hydrostatic equilibrium. Two basic geometries are allowed. A
<em>plane-parallel</em> geometry assumes that the domain is thin compared to
the radius of curvature of the star, and therefore the 1D base state
is perfectly aligned with the Cartesian state. A <em>spherical</em>
geometry is for modeling an entire star <a class="footnote-reference brackets" href="#id15" id="id1">1</a>. Here, the 1D base state is not
aligned with the Cartesian state. Figure <a class="reference external" href="#fig:base_state">[fig:base_state]</a> shows
these geometries.</p>
<p><a href="#id25"><span class="problematic" id="id26">|[fig:base_state] MAESTRO geometries, showing both the
1D base state and the full Cartesian state. (Left) For multi-level
problems in planar geometry, we force a direct alignment between the
radial array cell centers and the Cartesian grid cell centers by
allowing the radial base state spacing to change with space and
time. (Right) For multi-level problems in spherical geometry, since
there is no direct alignment between the radial array cell centers
and the Cartesian grid cell centers, we choose to fix the radial
base state spacing across levels. Figure taken
from :raw-latex:`\cite{multilevel}`.|</span></a>
<a href="#id27"><span class="problematic" id="id28">|[fig:base_state] MAESTRO geometries, showing both the
1D base state and the full Cartesian state. (Left) For multi-level
problems in planar geometry, we force a direct alignment between the
radial array cell centers and the Cartesian grid cell centers by
allowing the radial base state spacing to change with space and
time. (Right) For multi-level problems in spherical geometry, since
there is no direct alignment between the radial array cell centers
and the Cartesian grid cell centers, we choose to fix the radial
base state spacing across levels. Figure taken
from :raw-latex:`\cite{multilevel}`.|</span></a></p>
<p>MAESTRO can use adaptive mesh refinement to focus resolution on
complex regions of flow. For Cartesian/plane-parallel geometries, all
cells at the same height must be at the same level of refinement.
This restriction is to allow for the base state to directly align with
the Cartesian state everywhere. For spherical geometries, there is no
such restriction (again, see Figure <a class="reference external" href="#fig:base_state">[fig:base_state]</a>).
The MAESTRO grids are managed by the AMReX library, which is
distributed separately.</p>
</div>
<div class="section" id="the-maestro-ecosystem">
<h2>The MAESTRO ‘Ecosystem’<a class="headerlink" href="#the-maestro-ecosystem" title="Permalink to this headline">¶</a></h2>
<p>Building MAESTRO requires both the MAESTRO-specific source
files (distributed in the MAESTRO/ directory), and the
AMReX library (distributed separately, consisting of the amrex/ directory).
AMReX provides both a C++ and a Fortran framework. MAESTRO only uses the Fortran portions of AMReX. Figure <a class="reference external" href="#fig:arch:eco">[fig:arch:eco]</a>
shows the relationship between the different packages, highlighting
what goes into defining a specific MAESTRO problem.</p>
<p>Problems piece together various MAESTRO directories, choosing a
reaction network, equation of state, and conductivity routine to build
an executable. Briefly, the MAESTRO sub-directories are:</p>
<ul>
<li><p>MAESTRO/</p>
<p>The main MAESTRO algorithm directory.</p>
<p>Important directories under MAESTRO/ include:</p>
<ul>
<li><p>Docs/</p>
<p>Documentation describing the basic algorithm (including this
document).</p>
</li>
<li><p>Exec/</p>
<p>The various problem-setups. Each problem in MAESTRO gets it own
sub-directory under SCIENCE/, TEST_PROBLEMS/, or
UNIT_TESTS/. The GNUmakefile in the problem directory
includes the instructions on how to build the executable,
including what modules in Microphysics/ are used. Any file that
you place in a sub-directory here takes precedence over a file of
the same name in MAESTRO/. This allows problems to have
custom versions of the main MAESTRO routines (e.g. initial
conditions via initdata.f90. See § <a class="reference external" href="#sec:makefile">3.1</a> and
Chapter <a class="reference external" href="#ch:make">[ch:make]</a> for details on the build system).</p>
<ul>
<li><p>SCIENCE/</p>
<p>MAESTRO problem directories for science studies. These are
the setups that have been used for science papers in the past,
or are the basis for current science studies.</p>
</li>
<li><p>TEST_PROBLEMS/</p>
<p>MAESTRO problem directories for simple test problems that have
been used while developing MAESTRO. Many of these problems
have appeared in the various papers describing the
MAESTRO algorithm.</p>
</li>
<li><p>UNIT_TESTS/</p>
<p>Special MAESTRO problem directories that test only a single
component of the MAESTRO algorithm. These often have their
own main drivers (varden.f90) that setup and initialize
some data structures and then call only a few of the
MAESTRO routines. See Chapter <a class="reference external" href="#chapter:unit_tests">[chapter:unit_tests]</a> for details.</p>
</li>
</ul>
</li>
<li><p>Microphysics/ <a class="footnote-reference brackets" href="#id16" id="id2">2</a></p>
<p>The basic microphysics routines used by MAESTRO. These are organized
into the following sub-directories.</p>
<ul>
<li><p>conductivity/</p>
<p>Various routines for computing the thermal conductivity used in
the thermal diffusion part of the algorithm.</p>
</li>
<li><p>EOS/</p>
<p>The gamma_law_general/.</p>
</li>
<li><p>networks/</p>
<p>The basic general_null network that defines arbitrary
non-reacting species.</p>
</li>
</ul>
</li>
<li><p>Source/</p>
<p>The main MAESTRO source. Here you will find the driver routine,
the advection routines, etc. All MAESTRO problems will compile
this source.</p>
</li>
<li><p>Util/</p>
<p>Various helper routines exist in this directory. Some of these
are externally developed.</p>
<ul>
<li><p>BLAS/</p>
<p>Linear algebra routines.</p>
</li>
<li><p>initial_models/</p>
<p>Simple routines for generating toy initial models in hydrostatic equilibrium.</p>
</li>
<li><p>model_parser/</p>
<p>A simple Fortran module for reading in 1D initial model files.
This is used by the initialization routines to get the initial
model data.</p>
</li>
<li><p>random/</p>
<p>A random number generator.</p>
</li>
<li><p>VODE/</p>
<p>The VODE <a href="#id3"><span class="problematic" id="id4">:raw-latex:`\cite{vode}`</span></a> package for integrating ODEs. At the
moment, this is used for integrating various reaction networks.</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>The AMReX directory structure is shown in
Figure <a class="reference external" href="#fig:arch:amrex">[fig:arch:amrex]</a>. The subset of the directories that are
used by MAESTRO are:</p>
<ul>
<li><p>Src/</p>
<p>The main AMReX source directory. In MAESTRO, we only use the
Fortran source files. The core directories are:</p>
<ul>
<li><p>F_BaseLib/</p>
<p>The Fortran AMReX files. This is a library for describing
meshes consisting of a union of boxes. The AMReX modules
define the basic datatypes used in MAESTRO. AMReX also
provides the routines that handle the parallelization and I/O.</p>
</li>
<li><p>LinearSolvers/</p>
<p>The AMReX linear solvers—these are used to solve elliptic
problems in the MAESTRO algorithm.</p>
<ul>
<li><p>F_MG</p>
<p>The Fortran multigrid solver, with support for both
cell-centered and node-centered data.</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Tools/</p>
<p>Various tools used for building AMReX applications. Here we use:</p>
<ul>
<li><p>F_mk/</p>
<p>The generic Makefiles that store the compilation flags for various
platforms. Platform/compiler-specific options are stored in the
comps/ sub-directory.</p>
</li>
<li><p>F_scripts/</p>
<p>Some simple scripts that are useful for building, running,
maintaining MAESTRO.</p>
</li>
</ul>
</li>
</ul>
<p>Finally the amrex/Tools/Postprocessing/F_Src package provides simple
Fortran-based analysis routines (e.g. extract a line from a
multidimensional dataset) that operate on AMReX datasets. These are
described in § <a class="reference external" href="#sec:analysis">[sec:analysis]</a>. Several sub-directories with
python-based routines are also here. These are described both in
§ <a class="reference external" href="#sec:analysis">[sec:analysis]</a> and § <a class="reference external" href="#sec:vis:python">[sec:vis:python]</a>.</p>
</div>
<div class="section" id="adding-a-new-problem">
<span id="sec-adding-problems"></span><h2>Adding A New Problem<a class="headerlink" href="#adding-a-new-problem" title="Permalink to this headline">¶</a></h2>
<p>Different MAESTRO problems are defined in sub-directories under
Exec/ in SCIENCE, TEST_PROBLEMS, or UNIT_TESTS.
To add a problem, start by creating a new sub-directory—this is
where you will compile your problem and store all the problem-specific
files.</p>
<p>The minimum requirement to define a new problem would be a
GNUmakefile which describes how to build the application and an
input file which lists the runtime parameters. The problem-specific
executable is built in the problem directory by typing make.
Source files are found automatically by searching the directories
listed in the GNUmakefile. Customized versions of any source
files placed in the problem-directory override those with the same
name found elsewhere. Any unique source files (and not simply a
custom version of a file found elsewhere) needs to be listed in a file
called GPackage.mak in the problem-directory (and this needs to
be told to the build system—see below).</p>
<div class="section" id="the-gnumakefile">
<span id="sec-makefile"></span><h3>The GNUmakefile<a class="headerlink" href="#the-gnumakefile" title="Permalink to this headline">¶</a></h3>
<p>A basic GNUmakefile begins with:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">NDEBUG</span> <span class="p">:</span><span class="o">=</span> <span class="n">t</span>
<span class="n">MPI</span>    <span class="p">:</span><span class="o">=</span>
<span class="n">OMP</span>    <span class="p">:</span><span class="o">=</span>
</pre></div>
</div>
<p>Here, NDEBUG is true if we are building an optimized executable.
Otherwise, the debug version is built—this typically uses less
optimization and adds various runtime checks through compiler flags.
MPI and OMP are set to true if we want to use either MPI
or OpenMP for parallelization. If MPI := t, you will need to
have the MPI libraries installed, and their location may need to be
specified in MAESTRO/mk/GMakeMPI.mak.</p>
<p>The next line sets the compiler to be used for compilation:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">COMP</span> <span class="p">:</span><span class="o">=</span> <span class="n">gfortran</span>
</pre></div>
</div>
<p>The MAESTRO build system knows what options to use for various
compiler families. The COMP flag specifies which compiler to
use. Allowed values include Intel, gfortran, PGI,
PathScale, and Cray. The specific details of these
choices are defined in the MAESTRO/mk/comps/ directory.</p>
<p>MKVERBOSE set to true will echo the build commands to the
terminal as the are executed.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">MKVERBOSE</span> <span class="p">:</span><span class="o">=</span> <span class="n">t</span>
</pre></div>
</div>
<p>The next line defines where the top of the MAESTRO source tree is located.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">MAESTRO_TOP_DIR</span> <span class="p">:</span><span class="o">=</span> <span class="o">../../..</span>
</pre></div>
</div>
<p>A MAESTRO application is built from several packages (the
multigrid solver, an EOS, a reaction network, etc.). The core
MAESTRO packages are always included, so a problem only needs
to define the EOS, reaction network, and conductivities to
use, as well as any extra, problem-specific files.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">EOS_DIR</span> <span class="p">:</span><span class="o">=</span> <span class="n">helmholtz</span>
<span class="n">CONDUCTIVITY_DIR</span> <span class="p">:</span><span class="o">=</span> <span class="n">constant</span>
<span class="n">NETWORK_DIR</span> <span class="p">:</span><span class="o">=</span> <span class="n">ignition_simple</span>

<span class="n">EXTRA_DIR</span> <span class="p">:</span><span class="o">=</span> <span class="n">Util</span><span class="o">/</span><span class="n">random</span>
</pre></div>
</div>
<p>Note that the microphysics packages are listed simply by the name of
the directory containing the specific implementation (e.g. helmholtz).
By default, the build system will look in Microphysics/EOS/ for
the EOS, Microphysics/conductivity/ for the conductivity routine,
and Microphysics/networks/ for the reaction network. To
override this default search path, you can set EOS_TOP_DIR,
CONDUCTIVITY_TOP_DIR, and NETWORK_TOP_DIR respectively.</p>
<p>Generally, one does not need to include the problem directory itself
in EXTRA_DIR, unless there are unique source files found there,
described in a GPackage.mak file. These variables are
interpreted by the GMaestro.mak file and used to build a master
list of packages called Fmdirs. The build system will attempt
to build all of the files listed in the various GPackage.mak
files found in the Fmdirs directories. Furthermore,
Fmdirs will be will be added to the make VPATH, which
is the list of directories to search for source files. The problem
directory will always be put first in the VPATH, so any source
files placed there override those with the same name found elsewhere
in the source tree.</p>
<p>Some packages (for instance, the helmholtz
EOS) require Fortran include files. The Fmincludes variable
lists all those directories that contain include files that are
inserted into the Fortran source at compile time via the include
statement. Presently, the only instance of this is with the Helmholtz
general equation of state found in Microphysics/EOS/helmholtz/. This is
automatically handled by the GMaestro.mak instructions.</p>
<p>Runtime parameters listed in the MAESTRO/_parameters file are
parsed at compile time and the file probin.f90 is written and
compiled. This is a Fortran module that holds the values of the
runtime parameters and makes them available to any routine. By
default, the build system looks for a file called _parameters
in the problem directory and adds those parameters along with the
master list of MAESTRO parameters (MAESTRO/_parameters) to
the probin_module.</p>
<p>The final line in the GNUmakefile includes the rules to actually
build the executable.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>include $(MAESTRO_TOP_DIR)/GMaestro.mak
</pre></div>
</div>
<div class="section" id="handling-problem-specific-source-files">
<h4>Handling Problem-Specific Source Files<a class="headerlink" href="#handling-problem-specific-source-files" title="Permalink to this headline">¶</a></h4>
<p>As mentioned above, any source files placed in the problem directory
override a files with the same name found elsewhere in the source
tree. This allows you to create a problem-specific version of any
routine. Source files that are unique to this problem (i.e. there is
no file with the same name elsewhere in the source tree) need to be
listed in a file GPackage.mak in the problem directory, and
the problem-directory needs to be explicitly listed in the EXTRA_DIR
list in the GNUmakefile.</p>
</div>
</div>
<div class="section" id="defining-runtime-parameters">
<span id="sec-def-runtime-param"></span><h3>Defining Runtime Parameters<a class="headerlink" href="#defining-runtime-parameters" title="Permalink to this headline">¶</a></h3>
<p>The runtime parameters for the core MAESTRO algorithm are listed in
MAESTRO/_parameters. That file is parsed at compile-time by
the MAESTRO/write_probin.py script (along with any
problem-specific parameters). The script outputs the probin.f90
source file. Each line in the _parameters file has the form:
10em <em>data-type</em> 10em <em>value</em>
where <em>parameter</em> is the name of the runtime parameter,
<em>data-type</em> is one of {character, real,
integer, logical}, and the <em>value</em> specifies the default
value for the runtime parameter. Comments are indicated by a ‘
#’ character and are used to produce documentation about the
available runtime parameters. For the documentation, runtime parameters are grouped together
in the _parameters file into categories. The category headings
are defined by comments in the _parameters file and any comments
following that heading are placed into that category. The documentation
(Chapter <a class="reference external" href="#ch:parameters">[ch:parameters]</a>) is produced by the script
MAESTRO/docs/runtime_parameters/rp.py.</p>
<p>At runtime, the default values for the parameters can be overridden
either through the inputs file (by adding a line of the form:
parameter = value) or through a command-line argument (taking the
form: –parameter value). The probin_module makes the
values of the runtime parameters available to the various functions
in the code (see § <a class="reference external" href="#sec:probin">6.7</a>).</p>
<p>Problem-specific runtime parameters should be defined in the
problem-directory in a file called _parameters. This file will
be automatically found at compile time.</p>
</div>
<div class="section" id="preparing-the-initial-model">
<span id="sec-initial-models"></span><h3>Preparing the Initial Model<a class="headerlink" href="#preparing-the-initial-model" title="Permalink to this headline">¶</a></h3>
<p>MAESTRO models subsonic, non-hydrostatic flows as deviations from
a background state in hydrostatic equilibrium.
The solution in MAESTRO is broken up into a 1D base state and the 2-
or 3D full state. The job of the 1D base state in the algorithm is
to represent the hydrostatic structure. The full, Cartesian state
carries the departures from hydrostatic equilibrium. The underlying
formulation of the low Mach number equations assumes that the base
state is in hydrostatic equilibrium. At the start of a simulation,
the initial model is read in and taken as the base state. Therefore,
any initial model needs to already be in hydrostatic equilibrium.</p>
<p>The routines in Util/initial_models/ prepare an initial model
for MAESTRO. In general, there are two different proceduces that are
needed. The first type modify an existing 1D initial model produced
somewhere else (e.g. a 1D stellar evolution code), and map it onto a
uniform grid, at the desired resolution, using the equation of state
in MAESTRO, and using MAESTRO’s discretization of hydrostatic
equilibrium. The second type generate the initial model internally,
by integrating the condition of hydrostatic equilibrium together with
a simplifying assumption on the energy (e.g. isothermal or
isentropic). In both cases hydrostatic equilibrium is enforced as:</p>
<div class="math notranslate nohighlight">
\[\frac{p_{i+1} - p_i}{\Delta r} = \frac{1}{2} (\rho_i + \rho_{i+1})
g_{i+1/2}\]</div>
<p>Here, <span class="math notranslate nohighlight">\(g_{i+1/2}\)</span> is the edge-centered gravitational acceleration.</p>
<p>The toy_atm example provides a simple approximation for a thin
(plane-parallel) convectively-unstable accreted layer on the surface
of a star. This can be used as the starting point for a more complex
model.</p>
<p>MAESTRO initial models are read in by the Util/model_parser
routines. This expects the initial model to contain a header giving
the number of variables and their names, followed by rows of data
giving the coordinate and data values at that coordinate. The initial
model should contain the same species data (in the form of mass fractions) as
defined in the network module used by the MAESTRO problem.</p>
<p>Full details on which initial model routine matches each problem and
how the initial models are used to initialize the full state data can
be found in § <a class="reference external" href="#sec:initial_models_main">[sec:initial_models_main]</a>.</p>
</div>
<div class="section" id="customizing-the-initialization">
<h3>Customizing the Initialization<a class="headerlink" href="#customizing-the-initialization" title="Permalink to this headline">¶</a></h3>
<p>The best way to customize the initialization (e.g. add perturbations)
is to copy from one of the existing problems. The file initveldata.f90 controls the velocity field initialization and initscaldata.f90 controls the initialization of the scalars
(<span class="math notranslate nohighlight">\(\rho\)</span>, <span class="math notranslate nohighlight">\(\rho X_k\)</span>, <span class="math notranslate nohighlight">\(\rho h\)</span>). The reacting_bubble problem is a good
starting point for plane-parallel and wdconvect is a good
starting point for full stars.</p>
</div>
</div>
<div class="section" id="amrex-data-structures">
<h2>AMReX Data Structures<a class="headerlink" href="#amrex-data-structures" title="Permalink to this headline">¶</a></h2>
<p>MAESTRO’s gridding is handled by the AMReX library, which
contains the most fundamental objects used to construct parallel
block-structured AMR applications—different
regions of the domain can have different spatial resolutions.
At each level of refinement, the region covered by that level is divided
into grids, or boxes. The entire computational domain is covered by
the coarsest (base) level of refinement, often called level <span class="math notranslate nohighlight">\(\ell=0\)</span>, either by one
grid or divided into many grids.
Higher levels of refinement have cells that are finer by a “refinement ratio”
(typically 2). The grids are properly nested in the sense that the union
of grids at level <span class="math notranslate nohighlight">\(\ell+1\)</span> is contained in the union of grids at level <span class="math notranslate nohighlight">\(\ell\)</span>.
Furthermore, the containment is strict in the sense that, except at physical
boundaries, the level <span class="math notranslate nohighlight">\(\ell\)</span> grids are large enough to guarantee that there is
a border at least <span class="math notranslate nohighlight">\(n_{\rm buffer}\)</span> level <span class="math notranslate nohighlight">\(\ell\)</span> cells wide surrounding each level
<span class="math notranslate nohighlight">\(\ell +1\)</span> grid (grids at all levels are allowed to extend to the physical
boundaries so the proper nesting is not strict there).
For parallel computations, the boxes are spread across processors, in
a fashion designed to put roughly equal amounts of work on each
processor (load balancing).</p>
<p>On a grid, the data can be stored at cell-centers, on a face/edge, or
on the corners. In AMReX, data that is on an edge is termed ‘nodal’
in that direction (see Figure <a class="reference external" href="#fig:dataloc">[fig:dataloc]</a>). Data that is on the
corners is nodal in all spatial directions. In MAESTRO, the state
data (density, enthalpy, velocity, <span class="math notranslate nohighlight">\(\ldots\)</span>) is generally
cell-centered. Fluxes are nodal in the direction they represent.
A few quantities are nodal in all directions (e.g. <span class="math notranslate nohighlight">\(\phi\)</span> used in
the final velocity projection).</p>
<p>To simplify the description of the underlying AMR grid, AMReX provides a number of Fortran types. We briefly summarize the major
data types below. A more extensive introduction to AMReX is
provided by the AMReX User’s Guide, distributed with the library.</p>
<div class="section" id="box">
<h3>box<a class="headerlink" href="#box" title="Permalink to this headline">¶</a></h3>
<p>A box is simply a rectangular domain in space. Note that boxes
do not hold the state data themselves. A box has a lo
and hi index in each coordinate direction that gives the
location of the lower-left and upper-right corner with respect to
a global index space.</p>
<p>The computational domain is divided into boxes. The collection of
boxes with the same resolution comprise a level.
Figure <a class="reference external" href="#fig:boxes">[fig:boxes]</a> shows three boxes in the same level of
refinement. The position of the boxes is with respect to the global
index space at that level. For example, box 1 in the figure has
lo = (3,7) and hi = (9,12). Note that the global indexing
is 0-based.</p>
<p>The global index space covers the entire domain at a given resolution.
For a simulation setup with n_cellx = 32 and n_celly =
32, the coarsest level (level 1) has <span class="math notranslate nohighlight">\(32 \times 32\)</span> zones, and the
global index space will run from <span class="math notranslate nohighlight">\(0, \ldots, 31\)</span> in each coordinate
direction. Level 2 will have a global index space running from <span class="math notranslate nohighlight">\(0,
\ldots, 63\)</span> in each coordinate direction (corresponding to <span class="math notranslate nohighlight">\(64 \times
64\)</span> zones if fully refined), and level 3 will have a global index
space running from <span class="math notranslate nohighlight">\(0, \ldots, 127\)</span> in each coordinate direction
(corresponding to <span class="math notranslate nohighlight">\(128\times 128\)</span> zones if fully refined).</p>
<div class="section" id="common-operations-on-a-box">
<h4>Common Operations on a box<a class="headerlink" href="#common-operations-on-a-box" title="Permalink to this headline">¶</a></h4>
<p>A box declared as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">type</span><span class="p">(</span><span class="n">box</span><span class="p">)</span> <span class="p">::</span> <span class="n">mybox</span>
</pre></div>
</div>
<p>The upper and lower bounds of the box (in terms of the global
index space) are found via:</p>
<ul class="simple">
<li><p>lo = lwb(mybox) returns an array, lo(dm), with
the box lower bounds</p></li>
<li><p>hi = upb(mybox) returns an array, hi(dm), with
the box upper bounds</p></li>
</ul>
</div>
</div>
<div class="section" id="boxarray-and-ml-boxarray">
<h3>boxarray and ml_boxarray<a class="headerlink" href="#boxarray-and-ml-boxarray" title="Permalink to this headline">¶</a></h3>
<p>A boxarray is an array of boxes. A ml_boxarray is a collection of
boxarrays at different levels of refinement.</p>
</div>
<div class="section" id="layout-and-ml-layout">
<h3>layout and ml_layout<a class="headerlink" href="#layout-and-ml-layout" title="Permalink to this headline">¶</a></h3>
<p>A layout is basically a boxarray that knows information about other
boxes, or box “connectivity.” It contains additional information
that is used in filling ghost cells from other fine grids or from
coarser grids. This information is stored as long as the layout
exists so that we don’t have to recompute intersections every time we
do some operation with two multifabs that have that layout, for
example.</p>
<p>By separating the layout from the actual data, we can allocate and
destroy data that lives on the grid as needed.</p>
</div>
<div class="section" id="fab">
<h3>fab<a class="headerlink" href="#fab" title="Permalink to this headline">¶</a></h3>
<p>A fab is a “Fortran Array Box”. It contains the state data in a
multidimensional array and several box-types to describe where in
the global index-space it lives:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">type</span> <span class="n">fab</span>
   <span class="o">...</span>
   <span class="nb">type</span><span class="p">(</span><span class="n">box</span><span class="p">)</span> <span class="p">::</span> <span class="n">bx</span>
   <span class="nb">type</span><span class="p">(</span><span class="n">box</span><span class="p">)</span> <span class="p">::</span> <span class="n">pbx</span>
   <span class="nb">type</span><span class="p">(</span><span class="n">box</span><span class="p">)</span> <span class="p">::</span> <span class="n">ibx</span>
<span class="n">end</span> <span class="nb">type</span> <span class="n">fab</span>
</pre></div>
</div>
<p>bx represents the box in the global index-space over which the
fab is defined, pbx represents the “physical” box in the
sense that it includes bx plus ghost cells, and ibx is the
same as bx unless the fab is nodal. As can be seen in
Figure <a class="reference external" href="#fig:dataloc">[fig:dataloc]</a>, for the same grid nodal data requires one
more array element than cell-centered data. To address this ibx
is made by growing bx by one element along all nodal dimensions.</p>
<p>It’s important to note that all state data is stored in a
four-dimensional array <em>regardless of the problem’s
dimensionality</em>. The array is (nx,ny,nz,nc) in size, where
nc is the number of components, for instance representing
different fluid variables, and (nx,ny,nz) are the number of
cells in each respective spatial dimension. For 2D problems,
nz=1.</p>
<p>A fab would represent the data for a single box in the domain.
In MAESTRO, we don’t usually deal with fabs alone, but rather
we deal with multifabs, described next.</p>
</div>
<div class="section" id="multifab">
<h3>multifab<a class="headerlink" href="#multifab" title="Permalink to this headline">¶</a></h3>
<p>A multifab is a collection of fabs at the same level of
refinement. This is the primary data structure that MAESTRO routine operate on. A multilevel simulation stores the
data in an array of multifabs, where the array index refers
to the refinement level.</p>
<p>All fabs in a given multifab have the same number of ghost cells,
but different multifabs can have different numbers of ghost cells
(or no ghost cells).</p>
<div class="section" id="working-with-multifabs">
<h4>Working with multifabs<a class="headerlink" href="#working-with-multifabs" title="Permalink to this headline">¶</a></h4>
<p>To build a multifab, we need to provide a layout, the number of
components to store in the multifab  and the number of ghostcells. In
MAESTRO  the hierarchy of grids will be described by a single
ml_layout. A multifab can be declared and built at any time in a
simulation using the ml_layout, thereby allocating space at every
grid location in the simulation. The sequence to build a multifab appears as</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">type</span><span class="p">(</span><span class="n">multifab</span><span class="p">)</span> <span class="p">::</span> <span class="n">mfab</span><span class="p">(</span><span class="n">nlevs</span><span class="p">)</span>
<span class="o">...</span>
<span class="n">do</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nlevs</span>
   <span class="n">call</span> <span class="n">multifab_build</span><span class="p">(</span><span class="n">mfab</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">mla</span><span class="o">%</span><span class="n">la</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">nc</span><span class="p">,</span> <span class="n">ng</span><span class="p">)</span>
<span class="n">enddo</span>
</pre></div>
</div>
<p>Here, nc is the number of components and ng is the number
of ghostcells. The multifab is built one level at a time, using the
layout for that level taken from the ml_layout, mla.</p>
<p>A common operation on a multifab is to initialize it to <span class="math notranslate nohighlight">\(0\)</span>
everywhere. This can be done (level-by-level) as</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">call</span> <span class="n">setval</span><span class="p">(</span><span class="n">mfab</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">ZERO</span><span class="p">,</span> <span class="nb">all</span><span class="o">=.</span><span class="n">true</span><span class="o">.</span><span class="p">)</span>
</pre></div>
</div>
<p>where ZERO is the constant 0.0 from amrex_constants_module.</p>
<p>The procedure for accessing the data in each grid managed by the
multifab is shown in § <a class="reference external" href="#sec:example">[sec:example]</a>. Subroutines to add,
multiply, or divide two multifabs exist, as do subroutines to copy
from one multifab to another—see
amrex/Src/F_BaseLib/multifab.f90 for the full list of
routines that work with multifabs.</p>
<p>When you are done working with a multifab, its memory can be freed by
calling multifab_destroy on the multifab.</p>
</div>
</div>
<div class="section" id="bc-tower">
<h3>bc_tower<a class="headerlink" href="#bc-tower" title="Permalink to this headline">¶</a></h3>
<p>A bc_tower holds the information about what boundary conditions are
in effect for each variable in a
MAESTRO simulation. These are interpretted by the ghost cell filling
routines. See § <a class="reference external" href="#sec:arch:bcs">10</a> for more detail.</p>
</div>
</div>
<div class="section" id="maestro-data-organization">
<h2>MAESTRO Data Organization<a class="headerlink" href="#maestro-data-organization" title="Permalink to this headline">¶</a></h2>
<p>The state of the star in MAESTRO is described by both a
multidimensional state and the 1D base state. The full
multidimensional state is stored in multifabs while the base state
is simply stored in Fortran arrays. Here we describe the
major MAESTRO data-structures.</p>
<div class="section" id="s-multifabs-fluid-state">
<h3>‘s’ multifabs (fluid state)<a class="headerlink" href="#s-multifabs-fluid-state" title="Permalink to this headline">¶</a></h3>
<p>The fluid state (density, enthalpy, species, temperature, and tracer)
are stored together in a cell-centered multi-component multifab,
typically named sold, s1, s2, or snew
(depending on which time-level it represents). The enthalpy is stored
as <span class="math notranslate nohighlight">\((\rho h)\)</span>, and the species are stored as partial-densities <span class="math notranslate nohighlight">\((\rho
X_k)\)</span>. The tracer component is not used at present time, but can
describe an arbitrary advected quantity.</p>
<p>Individual state variables should be indexed using the integer keys
provided by the variables module (see §
<a class="reference external" href="#sec:variables_module">6.8</a>). For example, the integer rho_comp
will always refer to the density component of the state.</p>
<p>Note: the pressure is not carried as part of the ‘s’ multifabs.</p>
</div>
<div class="section" id="u-multifabs-fluid-velocity">
<h3>‘u’ multifabs (fluid velocity)<a class="headerlink" href="#u-multifabs-fluid-velocity" title="Permalink to this headline">¶</a></h3>
<p>The fluid velocity at time-levels <span class="math notranslate nohighlight">\(n\)</span> and <span class="math notranslate nohighlight">\(n+1\)</span> is stored in
a cell-centered multi-component multifab, typically named
uold or unew. Here the dm
components correspond to each coordinate direction.</p>
</div>
<div class="section" id="umac-the-mac-velocity">
<h3>umac (the MAC velocity)<a class="headerlink" href="#umac-the-mac-velocity" title="Permalink to this headline">¶</a></h3>
<p>In creating the advective fluxes, we need the time-centered velocity
through the faces of the zone—the <span class="math notranslate nohighlight">\(x\)</span>-velocity on the <span class="math notranslate nohighlight">\(x\)</span>-edges, the
<span class="math notranslate nohighlight">\(y\)</span>-velocity on the <span class="math notranslate nohighlight">\(y\)</span>-edges, etc. (see figure <a class="reference external" href="#fig:mac">[fig:mac]</a>). This
type of velocity discretization is termed the MAC velocity (after the
“marker-and-cell” method for free boundaries in incompressible
flows <a href="#id5"><span class="problematic" id="id6">:raw-latex:`\cite{harlowwelch:1965}`</span></a>).</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>The MAC velocities are allocated at each level of refinement, n,
by making a multifab array where each of the dm components is
nodal in its respective direction:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">type</span><span class="p">(</span><span class="n">multifab</span><span class="p">)</span> <span class="p">::</span> <span class="n">umac</span><span class="p">(</span><span class="n">nlevel</span><span class="p">,</span><span class="n">dm</span><span class="p">)</span>

<span class="n">do</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">nlevel</span>
   <span class="n">do</span> <span class="n">comp</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">dm</span>
      <span class="n">call</span> <span class="n">multifab_build_edge</span><span class="p">(</span><span class="n">umac</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">comp</span><span class="p">),</span> <span class="n">mla</span><span class="o">%</span><span class="n">la</span><span class="p">(</span><span class="n">n</span><span class="p">),</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">comp</span><span class="p">)</span>
   <span class="n">enddo</span>
<span class="n">enddo</span>
</pre></div>
</div>
</div>
<div class="section" id="base-state-arrays">
<h3>Base State Arrays<a class="headerlink" href="#base-state-arrays" title="Permalink to this headline">¶</a></h3>
<p>The base state is defined by <span class="math notranslate nohighlight">\(\rho_0\)</span>, <span class="math notranslate nohighlight">\(p_0\)</span>, and <span class="math notranslate nohighlight">\(w_0\)</span>. There is no
base state composition. Other arrays are defined as needed, such as
<span class="math notranslate nohighlight">\(h_0\)</span>, the base state enthalpy.</p>
<p>The base state arrays are 2-dimensional, with the first dimension
giving the level in the AMR hierarchy and the second the radial index
into the base state. For spherical geometries, the base state only
exists at a single level, so the first index will always be 1. The
radial index is 0-based, to be consistent with the indexing for the
Cartesian state data. For example, the base state density would be
dimensioned: rho0(nlevs,0:nr_fine-1). Here, nlevs is the
number of levels of refinement and nr_fine is the number of
cells in the radial direction at the finest level of refinement.</p>
<p>For multilevel, plane-parallel geometry, all grids at the same height
will have the same resolution so that the full state data is always
aligned with the base state (see Figure <a class="reference external" href="#fig:base_state">[fig:base_state]</a>). Base
state data on coarse grids that are covered by fine grids is not
guaranteed to be valid.</p>
<p>For spherical problems, the base state resolution, <span class="math notranslate nohighlight">\(\Delta r\)</span>, is
generally picked to be finer than the Cartesian grid resolution,
<span class="math notranslate nohighlight">\(\Delta x\)</span>, i.e. <span class="math notranslate nohighlight">\(\Delta r &lt; \Delta x\)</span>. The ratio is controlled
by the parameter drdxfac.</p>
<p>Note there are no ghost cells for the base state outside of the
physical domain. For plane-parallel, multilevel simulations, there
are ghostcells at the jumps in refinement—these are filled by the
fill_code_base routine. The convention when dealing with the
base state is that we only access it inside of the valid physical
domain. Any multi-dimensional quantity that is derived using the base
state then has its ghost cells filled by the usually multifab ghost
cell routines.</p>
</div>
</div>
<div class="section" id="maestro-helper-modules">
<h2>MAESTRO Helper Modules<a class="headerlink" href="#maestro-helper-modules" title="Permalink to this headline">¶</a></h2>
<p>A number of MAESTRO modules appear frequently throughout the source.
Below, we describe some of the more common functionality of the most
popular modules.</p>
<div class="section" id="average-module">
<h3>average_module<a class="headerlink" href="#average-module" title="Permalink to this headline">¶</a></h3>
<p>The average_module module provides a routine average that takes
a multilevel multifab array and averages the full Cartesian data
onto the 1D base state.</p>
</div>
<div class="section" id="eos-module">
<h3>eos_module<a class="headerlink" href="#eos-module" title="Permalink to this headline">¶</a></h3>
<p>The eos_module provides the interface to the equation of
state to connect the state variables thermodynamically. It
gets the information about the fluid species from the network
module (for example, the atomic number, <span class="math notranslate nohighlight">\(Z\)</span>, and atomic weight, <span class="math notranslate nohighlight">\(A\)</span>,
of the nuclei).</p>
<p>Presently there is a single EOS that comes with MAESTRO, tt gamma_law_general,
but many more are available through the external Microphysics repo <a class="footnote-reference brackets" href="#id17" id="id7">3</a>. The Microphysics EOSs share the same interface and can be compiled into MAESTRO directly.
Here are the more popular EOSs:</p>
<ul>
<li><p>helmholtz represents a general stellar equation
of state, consisting of nuclei (as an ideal gas), radiation,
and electrons (with arbitrary degeneracy and degree of relativity).
This equation of state is that described in <a href="#id8"><span class="problematic" id="id9">:raw-latex:`\cite{timmes_eos}`</span></a>.</p>
<p>A runtime parameter, use_eos_coulomb, is defined in
this EOS to enable/disable Coulomb corrections.</p>
</li>
<li><p>gamma_law_general assumes an ideal gas with a mixed
composition and a constant ratio of specific heats, <span class="math notranslate nohighlight">\(\gamma\)</span>:</p>
<div class="math notranslate nohighlight">
\[p = \rho e (\gamma - 1) = \frac{\rho k_B T}{\mu m_p}\]</div>
<p>where <span class="math notranslate nohighlight">\(k_B\)</span> is Boltzmann’s constant and <span class="math notranslate nohighlight">\(m_p\)</span> is the mass of the
proton.
The mean molecular weight, <span class="math notranslate nohighlight">\(\mu\)</span>, is computed assuming
electrically neutral atoms:</p>
<div class="math notranslate nohighlight">
\[\mu = \left ( \sum_k \frac{X_k}{A_k} \right )^{-1}\]</div>
<p>An option in the source code itself exists for treating the
species as fully-ionized, but there is no runtime-parameter to
make this switch.</p>
</li>
<li><p>multigamma is an ideal gas equation of state where each
species can have a different value of <span class="math notranslate nohighlight">\(\gamma\)</span>. This mainly affects
how the internal energy is constructed as each species, represented
with a mass fraction <span class="math notranslate nohighlight">\(X_k\)</span> will have its contribution to the total
specific internal energy take the form of :math:<a href="#id10"><span class="problematic" id="id11">`</span></a>e = p/rho/(gamma_k -</p>
<blockquote>
<div><p>1)`. The main thermodynamic quantities take the form:</p>
</div></blockquote>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
p &amp;= \frac{\rho k T}{m_u} \sum_k \frac{X_k}{A_k} \\
e &amp;= \frac{k T}{m_u} \sum_k \frac{1}{\gamma_k - 1} \frac{X_k}{A_k} \\
h &amp;= \frac{k T}{m_u} \sum_k \frac{\gamma_k}{\gamma_k - 1} \frac{X_k}{A_k}\end{aligned}\end{split}\]</div>
<p>We recognize that the usual astrophysical <span class="math notranslate nohighlight">\(\bar{A}^{-1} = \sum_k
X_k/A_k\)</span>, but now we have two other sums that involve different
<span class="math notranslate nohighlight">\(\gamma_k\)</span> weightings.</p>
<p>The specific heats are constructed as usual,</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
c_v &amp;= \left . \frac{\partial e}{\partial T} \right |_\rho =
    \frac{k}{m_u} \sum_k \frac{1}{\gamma_k - 1} \frac{X_k}{A_k} \\
c_p &amp;= \left . \frac{\partial h}{\partial T} \right |_p =
    \frac{k}{m_u} \sum_k \frac{\gamma_k}{\gamma_k - 1} \frac{X_k}{A_k}\end{aligned}\end{split}\]</div>
<p>and it can be seen that the specific gas constant, <span class="math notranslate nohighlight">\(R \equiv c_p - c_v\)</span> is
independent of the <span class="math notranslate nohighlight">\(\gamma_i\)</span>, and is simply <span class="math notranslate nohighlight">\(R = k/m_u\bar{A}\)</span> giving the
usual relation that <span class="math notranslate nohighlight">\(p = R\rho T\)</span>. Furthermore, we can show</p>
<div class="math notranslate nohighlight">
\[\Gamma_1 \equiv \left . \frac{\partial \log p}{\partial \log \rho} \right |_s =
   \left ( \sum_k \frac{\gamma_k}{\gamma_k - 1} \frac{X_k}{A_k} \right ) \bigg /
   \left ( \sum_k \frac{1}{\gamma_k - 1} \frac{X_k}{A_k} \right ) =
\frac{c_p}{c_v} \equiv \gamma_\mathrm{effective}\]</div>
<p>and <span class="math notranslate nohighlight">\(p = \rho e (\gamma_\mathrm{effective} - 1)\)</span>.</p>
<p>This equation of state takes several runtime parameters that can set the
<span class="math notranslate nohighlight">\(\gamma_i\)</span> for a specific species:</p>
<ul class="simple">
<li><p>eos_gamma_default: the default <span class="math notranslate nohighlight">\(\gamma\)</span> to apply for
all species</p></li>
<li><p>species_X_name and species_X_gamma: set the <span class="math notranslate nohighlight">\(\gamma_i\)</span>
for the species whose name is given as species_X_name to the
value provided by species_X_gamma. Here, X can be one
of the letters: a, b, or c, allowing us to specify
custom <span class="math notranslate nohighlight">\(\gamma_i\)</span> for up to three different species.</p></li>
</ul>
</li>
</ul>
<p>The thermodynamic quantities are stored in a Fortran type eos_t,
which has fields for all the thermodynamic inputs and outputs. The
type definition is brought in through eos_type_module.</p>
<blockquote>
<div><p><a class="footnote-reference brackets" href="#id18" id="id12">4</a></p>
</div></blockquote>
<p>The first argument to the eos call is an integer key that
specifies which thermodynamic variables (in addition to the mass
fractions) are used as input. EOS input options are listed
in table <a class="reference external" href="#arch:table:eosinput">[arch:table:eosinput]</a>.</p>
<table class="docutils align-center" id="id23">
<caption><span class="caption-text">[arch:table:eosinput] EOS input flags</span><a class="headerlink" href="#id23" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 36%" />
<col style="width: 64%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>key</p></th>
<th class="head"><p>input quantities</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>eos_input_rt</p></td>
<td><p><span class="math notranslate nohighlight">\(\rho\)</span>, <span class="math notranslate nohighlight">\(T\)</span></p></td>
</tr>
<tr class="row-odd"><td><p>eos_input_rh</p></td>
<td><p><span class="math notranslate nohighlight">\(\rho\)</span>, <span class="math notranslate nohighlight">\(h\)</span></p></td>
</tr>
<tr class="row-even"><td><p>eos_input_tp</p></td>
<td><p><span class="math notranslate nohighlight">\(T\)</span>, <span class="math notranslate nohighlight">\(p\)</span></p></td>
</tr>
<tr class="row-odd"><td><p>eos_input_rp</p></td>
<td><p><span class="math notranslate nohighlight">\(\rho\)</span>, <span class="math notranslate nohighlight">\(p\)</span></p></td>
</tr>
<tr class="row-even"><td><p>eos_input_re</p></td>
<td><p><span class="math notranslate nohighlight">\(\rho\)</span>, <span class="math notranslate nohighlight">\(e\)</span></p></td>
</tr>
<tr class="row-odd"><td><p>eos_input_ps</p></td>
<td><p><span class="math notranslate nohighlight">\(p\)</span>, <span class="math notranslate nohighlight">\(s\)</span></p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="fill-3d-module">
<h3>fill_3d_module<a class="headerlink" href="#fill-3d-module" title="Permalink to this headline">¶</a></h3>
<p>The fill_3d_module provides routines that map from the 1D
base state to the full Cartesian 2- or 3D state. Variations in the
routines allow for cell-centered or edge-centered data on either the
base state or full Cartesian state.</p>
</div>
<div class="section" id="fundamental-constants-module">
<h3>fundamental_constants_module<a class="headerlink" href="#fundamental-constants-module" title="Permalink to this headline">¶</a></h3>
<p>The fundamental_constants_module provides a simple list of
various fundamental constants (e.g. Newton’s gravitational constant)
in CGS units.</p>
</div>
<div class="section" id="geometry">
<h3>geometry<a class="headerlink" href="#geometry" title="Permalink to this headline">¶</a></h3>
</div>
<div class="section" id="network">
<h3>network<a class="headerlink" href="#network" title="Permalink to this headline">¶</a></h3>
<p>The network module defines the number species advected by the
code (nspec), their ordering, and gives their basic properties
(like atomic number, <span class="math notranslate nohighlight">\(Z\)</span>, and atomic mass, <span class="math notranslate nohighlight">\(A\)</span>). All MAESTRO problems
require a network module, even if there are no reactions
modeled. Many different reaction modules (containing different sets
of isotopes) exist in Microphysics/networks. The particular network
used by a problem is defined in the problem’s GNUmakefile.</p>
<p>To find the location of a particular species (for instance, “carbon-12”)
in the allowed range of 1:nspec, you do the following query:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ic12</span> <span class="o">=</span> <span class="n">network_species_index</span><span class="p">(</span><span class="s2">&quot;carbon-12&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>If the resulting index is -1, then the requested species was not
found.</p>
</div>
<div class="section" id="probin-module">
<span id="sec-probin"></span><h3>probin_module<a class="headerlink" href="#probin-module" title="Permalink to this headline">¶</a></h3>
<p>probin_module provides access to the runtime parameters.
The runtime parameters appear simply as module variables. To get the
value of a parameter, one simply needs to ‘use probin_module’.
The preferred method is to add the ‘only’ clause to the
use statement and explicitly list only those parameters that
are used in the routine. Defining new runtime parameters is
described in § <a class="reference external" href="#sec:def_runtime_param">3.2</a>.</p>
</div>
<div class="section" id="variables">
<span id="sec-variables-module"></span><h3>variables<a class="headerlink" href="#variables" title="Permalink to this headline">¶</a></h3>
<p>The variables module provides integer keys to index the state
multifabs and other arrays dealing with the scalar quantities. The
most commonly used keys are are list in table <a class="reference external" href="#arch:table:variables">[arch:table:variables]</a>.</p>
<table class="docutils align-center" id="id24">
<caption><span class="caption-text">[arch:table:variables] Common variables module keys</span><a class="headerlink" href="#id24" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 15%" />
<col style="width: 85%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>rho_comp</p></td>
<td><p>density</p></td>
</tr>
<tr class="row-even"><td><p>rhoh_comp</p></td>
<td><p>density <span class="math notranslate nohighlight">\(\times\)</span> specific enthalpy, <span class="math notranslate nohighlight">\((\rho h)\)</span></p></td>
</tr>
<tr class="row-odd"><td><p>spec_comp</p></td>
<td><p>first species partial density, <span class="math notranslate nohighlight">\((\rho X_1)\)</span></p></td>
</tr>
<tr class="row-even"><td><p>temp_comp</p></td>
<td><p>temperature</p></td>
</tr>
</tbody>
</table>
<p>The species indices are contiguous in the state array, spanning
spec_comp:spec_comp-1+nspec. To find a particular species, a
query can be made through the network module, such as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ic12</span> <span class="o">=</span> <span class="n">network_species_index</span><span class="p">(</span><span class="s2">&quot;carbon-12&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>and then the fab can be indexed using spec_comp-1+ic12 to
get “carbon-12”.
The variables module also provides keys for the plotfile
variables and boundary condition types.</p>
<p>Other keys in the variables modules are reserved for boundary
conditions (foextrap_comp and hoextap_comp), the
projection of the pressure (press_comp), or constructing
the plotfile.</p>
</div>
</div>
<div class="section" id="amrex-helper-modules">
<h2>AMReX Helper Modules<a class="headerlink" href="#amrex-helper-modules" title="Permalink to this headline">¶</a></h2>
<p>There are a large number of modules in amrex/ that provide
the core functionality for managing grids. Here we describe
the most popular such modules.</p>
<div class="section" id="amrex-constants">
<h3>amrex_constants<a class="headerlink" href="#amrex-constants" title="Permalink to this headline">¶</a></h3>
<p>This module provides descriptive names for a number of common double precision
numbers, e.g. ONE = 1.d0. This enhances the readability of
the code.</p>
</div>
<div class="section" id="parallel">
<h3>parallel<a class="headerlink" href="#parallel" title="Permalink to this headline">¶</a></h3>
<p>All MPI calls are wrapped by functions in the parallel module. For
serial jobs, the wrappers simply do the requested operation on processor.
By wrapping the calls, we can easily switch between serial and parallel
builds.</p>
</div>
</div>
<div class="section" id="sec-example-example-accessing-state-and-mac-data">
<h2>[sec:example] Example: Accessing State and MAC Data<a class="headerlink" href="#sec-example-example-accessing-state-and-mac-data" title="Permalink to this headline">¶</a></h2>
<p>In MAESTRO, the state data is stored in a cell-centered multifab array
(the array index refers to the AMR level) and the MAC velocities are
stored in a 2D nodal multifab array (with indices referring to the AMR
level and the velocity component). Here we demonstrate a typical way
to extract the state and MAC velocity data.</p>
<p>All MAESTRO routines are contained in a module, to allow for compile-time
argument checking.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">module</span> <span class="n">example_module</span>

<span class="n">contains</span>
</pre></div>
</div>
<p>The main interface to our routine is called example—this will
take the multifabs containing the data and then pass them to the
work routines, example_2d or example_3d, depending on
the dimensionality.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">subroutine</span> <span class="n">example</span><span class="p">(</span><span class="n">mla</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">umac</span><span class="p">,</span><span class="n">dx</span><span class="p">,</span><span class="n">dt</span><span class="p">)</span>

  <span class="n">use</span> <span class="n">multifab_module</span>
  <span class="n">use</span> <span class="n">ml_layout_module</span>
  <span class="n">use</span> <span class="n">variables</span><span class="p">,</span> <span class="n">only</span><span class="p">:</span> <span class="n">rho_comp</span>
</pre></div>
</div>
<p>Here, the
multifab_module defines
the multifab data type. The ml_layout_module defines the
datatype for a ml_layout—many routines will take an ml_layoutto
allow us to fill ghostcells. The variables module is a
MAESTRO module that provides integer keys for indexing the state
arrays. In this case the integer rho_comp refers to the
location in the state array corresponding to density.</p>
<p>Next we declare the subroutine arguments:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">type</span><span class="p">(</span><span class="n">ml_layout</span><span class="p">)</span> <span class="p">,</span> <span class="n">intent</span><span class="p">(</span><span class="ow">in</span>   <span class="p">)</span> <span class="p">::</span> <span class="n">mla</span>
<span class="nb">type</span><span class="p">(</span><span class="n">multifab</span><span class="p">)</span>  <span class="p">,</span> <span class="n">intent</span><span class="p">(</span><span class="n">inout</span><span class="p">)</span> <span class="p">::</span> <span class="n">s</span><span class="p">(:)</span>
<span class="nb">type</span><span class="p">(</span><span class="n">multifab</span><span class="p">)</span>  <span class="p">,</span> <span class="n">intent</span><span class="p">(</span><span class="n">inout</span><span class="p">)</span> <span class="p">::</span> <span class="n">umac</span><span class="p">(:,:)</span>
<span class="n">double</span> <span class="n">precision</span><span class="p">,</span> <span class="n">intent</span><span class="p">(</span><span class="ow">in</span>   <span class="p">)</span> <span class="p">::</span> <span class="n">dx</span><span class="p">(:,:),</span><span class="n">dt</span>
</pre></div>
</div>
<p>Here, s(:) is our multifab array that holds the state data.
with the array index in s refers to the AMR level. The MAC
velocities are held in the multifab umac, with the array
indices referring to the AMR level and the component.</p>
<p>Local variable declarations come next:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>! Local variables
double precision, pointer :: sp(:,:,:,:)
double precision, pointer :: ump(:,:,:,:), vmp(:,:,:,:), wmp(:,:,:,:)
integer :: i,n,dm,nlevs,ng_sp,ng_um
integer :: lo(mla%dim),hi(mla%dim)
</pre></div>
</div>
<p>Amongst the local variables we define here are a pointer,
sp, that will point to a single fab from the
multifab s, and a pointer for each component of the MAC
velocity, ump, vmp, and wmp (for a 2D run,
we won’t use wmp). We note that regardless of the dimensionality,
these pointers are 4-dimensional: 3 spatial + 1 component.</p>
<p>Next we get the dimensionality and number of levels</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">dm</span> <span class="o">=</span> <span class="n">mla</span><span class="o">%</span><span class="n">dim</span>
<span class="n">nlevs</span> <span class="o">=</span> <span class="n">mla</span><span class="o">%</span><span class="n">nlevel</span>
</pre></div>
</div>
<p>Each multifab can have their own number of ghostcells, so we get
these next:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ng_sp</span> <span class="o">=</span> <span class="n">nghost</span><span class="p">(</span><span class="n">s</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="n">ng_um</span> <span class="o">=</span> <span class="n">nghost</span><span class="p">(</span><span class="n">umac</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
<p>By convention, all levels in a given multifab have the same number of
ghostcells, so we use level 1 in the nghost() call. We also use
the same number of ghostcells for each component of the velocity, so
we only need to consider the first component in the nghost()
call. The ghostcells will be needed to access the data stored in the
fabs.</p>
<p>To access the data, we loop over all the levels, and all the boxes in
the given level.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">do</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">nlevs</span>
   <span class="n">do</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nfabs</span><span class="p">(</span><span class="n">s</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
</pre></div>
</div>
<p>nfabs(s(n)) is simply the number of boxes in level n on
the current processor. Each processor knows which fabs in its
multifabare local to that processor, and this loop will only loop
over those.</p>
<p>For a given box, we get the data and the bounds of the box.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sp</span>  <span class="o">=&gt;</span> <span class="n">dataptr</span><span class="p">(</span><span class="n">s</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">i</span><span class="p">)</span>
<span class="n">ump</span> <span class="o">=&gt;</span> <span class="n">dataptr</span><span class="p">(</span><span class="n">umac</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="n">i</span><span class="p">)</span>
<span class="n">vmp</span> <span class="o">=&gt;</span> <span class="n">dataptr</span><span class="p">(</span><span class="n">umac</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span><span class="n">i</span><span class="p">)</span>
<span class="n">lo</span> <span class="o">=</span>  <span class="n">lwb</span><span class="p">(</span><span class="n">get_box</span><span class="p">(</span><span class="n">s</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">i</span><span class="p">))</span>
<span class="n">hi</span> <span class="o">=</span>  <span class="n">upb</span><span class="p">(</span><span class="n">get_box</span><span class="p">(</span><span class="n">s</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">i</span><span class="p">))</span>
</pre></div>
</div>
<p>The actual data array is accessed through the dataptr function,
which takes a multifab (e.g. s(n)) and the index of the
box (i) we want. We see that the <span class="math notranslate nohighlight">\(x\)</span> MAC velocity for the
current box is stored in ump and the <span class="math notranslate nohighlight">\(y\)</span> MAC velocity is stored
in vmp. We don’t get the <span class="math notranslate nohighlight">\(z\)</span> velocity data here, since that
would not be available for a 2D run—we defer that until we test on
the dimensionality below.</p>
<p>Finally, the index bounds of the box (just the data, not the ghostcells) are
stored in the dm-dimensional arrays lo and hi. These indices
refer to the current box, and hold for both the state, sp, and the MAC
velocity, ump and vmp. However, since the MAC velocity is nodal
in the component direction, the loops over the valid data will differ
slight (as we see below).</p>
<p>With the data extracted, we call a subroutine to operate on it. We use
different subroutines for the different dimensionalities (and many times
have a separate routine for spherical geometries).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>        select case (dm)
        case (2)
           call example_2d(sp(:,:,1,rho_comp),ng_sp, &amp;
                           ump(:,:,1,1),vmp(:,:,1,1),ng_um, &amp;
                           lo,hi,dx(n,:),dt)
        case (3)
           wmp =&gt; dataptr(umac(n,3),i)
           call example_3d(sp(:,:,:,rho_comp),ng_sp, &amp;
                           ump(:,:,:,1),vmp(:,:,:,1),wmp(:,:,:,1),ng_um, &amp;
                           lo,hi,dx(n,:),dt)
        end select
     enddo    ! end loop over boxes

  enddo    ! end loop over levels

end subroutine example
</pre></div>
</div>
<p>We call either the function
example_2d for two-dimensional data or example_3d
for three-dimensional data. Note that in the two-dimensional
case, we index the data as sp(:,:,1,rho_comp). Here a
‘1’ is used as the ‘z’-coordinate spatial index, since this
is a 2D problem, and the density component of the state is selected
(using the integer key rho_comp). The 3D version accesses
the data as sp(:,:,:,rho_comp)—only the component regarding
the variable is needed here. Notice that we also pass through
the number of ghostcells for each of the quantities.</p>
<p>This routine will be supplimented with example_2d and
example_3d, which actually operate on the data. The form of
the 2D function is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  subroutine example_2d(density,ng_sp, &amp;
                        umac,vmac,ng_um, &amp;
                        lo,hi,dx,dt)

    use amrex_constants_module
    use probin_module, only: prob_lo

    integer        , intent(in) :: lo(:),hi(:), ng_sp, ng_um
    double precision, intent(in) :: density(lo(1)-ng_sp:,lo(2)-ng_sp:)
    double precision, intent(in) ::    umac(lo(1)-ng_um:,lo(2)-ng_um:)
    double precision, intent(in) ::    vmac(lo(1)-ng_um:,lo(2)-ng_um:)

    double precision, intent(in) :: dx(:),dt

    integer         :: i, j
    double precision :: x, y
    double precision :: dens, u, v

    do j = lo(2), hi(2)
       y = prob_lo(2) + (dble(j) + HALF)*dx(2)

       do i = lo(1), hi(1)
          x = prob_lo(1) + (dble(i) + HALF)*dx(1)

          dens = density(i,j)

          ! compute cell-centered velocity
          u = HALF*(umac(i,j) + umac(i+1,j))
          v = HALF*(vmac(i,j) + vmac(i,j+1))

          ! operate on the data
          ! ...

       enddo
    enddo

  end subroutine example_2d

end module example_module
</pre></div>
</div>
<p>In this function, the bounds of the density array take
into account the ng_sp ghostcells and the index space of the
current box. Likewise, the MAC velocities refer to the ng_um
ghostcells. The j and i loops loop over all the valid
zones. Coordinate information is computed from dx and
prob_lo which is the physical lower bound of the domain.
amrex_constants_module declares useful double-precision
constants, like HALF (0.5). Here, we see how to access the
density for the current zone and compute the cell-centered velocities
from the MAC velocities. By convection, for a nodal array, the
indices refer to the <em>lower</em> interface in the nodal direction, so
for umac, umac(i,j) and umac(i+1,j) are the <span class="math notranslate nohighlight">\(x\)</span> MAC
velocities on the lower and upper edge of the zone in the
<span class="math notranslate nohighlight">\(x\)</span>-direction.</p>
<p>The three-dimensional case is similar, with the density array
declared as</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">density</span><span class="p">(</span><span class="n">lo</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="n">ng_sp</span><span class="p">:,</span><span class="n">lo</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">-</span><span class="n">ng_sp</span><span class="p">:,</span><span class="n">lo</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">-</span><span class="n">ng_sp</span><span class="p">:)</span>
</pre></div>
</div>
<p>and an additional loop over the ‘z’ coordinate (from lo(3) to
hi(3)).</p>
<p>In this example, we looped over the valid zones. If we wished to loop
over the interfaces bounding the valid zones, in the <span class="math notranslate nohighlight">\(x\)</span>-direction,
we would loop as</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>do j = lo(2), hi(2)
   do i = lo(1), hi(1)+1
      ! access umac(i,j)
   enddo
enddo
</pre></div>
</div>
</div>
<div class="section" id="filling-ghostcells">
<h2>Filling Ghostcells<a class="headerlink" href="#filling-ghostcells" title="Permalink to this headline">¶</a></h2>
<p>Ghostcells are filled through a variety of different routines, depending
on the objective.</p>
<ul class="simple">
<li><p>multifab_fill_boundary fills ghost cells for two
adjacent grids at the same level, which als includes periodic domain
boundary ghost cells.</p></li>
<li><p>multifab_physbc fills ghostcells at the physical boundaries.</p></li>
<li><p>multifab_fill_ghost_cells is used for multilevel
problems, and fills ghostcells in the finer grid (level n) by
interpolating from data in the coarser grid (level n-1).
This function, by default, will also call multifab_fill_boundary
and multifab_physbc for both levels n and n-1 (you
can override this behavior for speed optimization purposes).
This call is usually preceded by a call to
ml_cc_restriction_c which sets the level n-1 data to be
the average of the level n data covering it.</p></li>
</ul>
<p>You generally won’t see calls in the MAESTRO source code to these subroutines,
as there is now a special AMReX subroutine, ml_restrict_and_fill,
that takes an array of multifabs at different level, and in order calls:
(1) ml_cc_restriction_c, (2) multifab_fill_boundary,
(3) multifab_physbc, and (4) multifab_fill_ghost_cells.
These four subroutines are called in such a way to avoid extra
ghostcell filling, saving on communication time. You can specify the
starting component, starting boundary condition component,
the number of components, the number of ghost cells,
and whether or not you want to use the same boundary condition component
for all variables.</p>
</div>
<div class="section" id="boundary-conditions">
<span id="sec-arch-bcs"></span><h2>Boundary Conditions<a class="headerlink" href="#boundary-conditions" title="Permalink to this headline">¶</a></h2>
<p>When MAESTRO is run, the boundary condition parameters are read in
from the input file and used to build the bc_tower. The
bc_tower consists of a bc_level object for each level of resolution
in the simulation. The bc_level contains 3 different descriptions of
the boundary conditions for each box in the domain at that level of
refinement: phys_bc_level_array, adv_bc_level_array,
and ell_bc_level_array. In all cases, the boundary
conditions are specified via integer values that are defined in
bc_module (part of AMReX).</p>
<p>Each level has a phys_bc_level_array(0:ngrids,dim,2) array,
where ngrids is the number of boxes on that level, dim is
the coordinate direction, and the last index refers to the lower (1)
or upper (2) edge of the box in the given coordinate direction. This
stores the <em>physical desciption</em> of the boundary type (outlet, inlet,
slipwall, etc.)—this description is independent of the variables
that live on the grid. The phys_bc_level_array(0,:,:) ‘box’
refers to the entire domain. If an edge of a box is not on a physical
boundary, then it is set to a default value (typically
INTERIOR). These boundary condition types are used to interpret
the actual method to fill the ghostcells for each variable, as
described in adv_bc_level_array and
ell_bc_level_array.</p>
<p>Whereas phys_bc_level_array provides a physical description
of the type of boundary, the array adv_bc_level_array
describes the <em>action</em> taken (e.g. reflect, extrapolate, etc.)
for each variable when filling boundaries.
adv_bc_level_array specifically describes the boundary
conditions that are in play for the advection (hyperbolic) equations.
The form of this array is
adv_bc_level_array(0:ngrids,dim,2,nvar) where the additional
component, nvar, allows for each state variable that lives on a
grid to have different boundary condition actions associated with it.
The convention is that the first dm variables in bc_level(where dm is
the dimensionality of the simulation) refer to the
velocity components, and the subsequent slots are for the other
standard variables described in the variables_module. For
instance, to reference the boundary condition for density, one would
index with dm+rho_comp. For temporary variables that are
created on the fly in the various routines in MAESTRO there may not
be a variable name in variables_module that describes the
temporary variable. In this case, the special variables
foextrap_comp and hoextrap_comp (first-order and high-order
extrapolation) are used.</p>
<p>ell_bc_level_array is the analog to
adv_bc_level_array for the elliptic solves in MAESTRO. This
will come into play in the multigrid portions of the code. The
actions that are used for ell_bc_level_array are either
Dirichlet or Neumann boundary condtions. For the velocity
projections, we are dealing with a pressure-like quantity, <span class="math notranslate nohighlight">\(\phi\)</span>, so
the pressure boundary conditions here reflect the behavior we want for
the velocity. After the projection, it is <span class="math notranslate nohighlight">\(\nabla \phi\)</span> that modifies
the velocity field. At a wall or for inflow conditions, we already
have the velocity we want at the boundary, so we want the velocity to
remain unchanged after the projection. This requires <span class="math notranslate nohighlight">\(d\phi/dn=0\)</span> on
those boundaries. For outflow, we impose a condition that we do not
want the boundaries to introduce any tangental acceleration (or
shear), this is equivalent to setting <span class="math notranslate nohighlight">\(\phi = 0\)</span> (then <span class="math notranslate nohighlight">\(\partial
\phi/\partial t = 0\)</span>, with <span class="math notranslate nohighlight">\(t\)</span> meaning ‘tangental’). This allows the
velocity to adjust as needed to the domain (see, for example,
<a href="#id13"><span class="problematic" id="id14">:raw-latex:`\cite{almgrenBellSzymczak:1996}`</span></a>).</p>
<p>The actual filling of the ghostcells according to the descriptions
contained in the bc_tower is carried out by the multifab_physbc routine. When you have an EXT_DIR
condition in multifab_physbc (an specified in the inputs file
as inlet), the advection solver (via the slope routine) and
linear solvers will then assume that the value in the ghost cells is
equal to the value that actually lies on the wall.</p>
</div>
<div class="section" id="multigrid">
<h2>Multigrid<a class="headerlink" href="#multigrid" title="Permalink to this headline">¶</a></h2>
<p>MAESTRO uses the multigrid solver to enforce the divergence
constraint both on the half-time edge-centered advective velocities
(the “MAC projection”) and on the final cell-centered velocities
(the “HG projection”). For the MAC projection, since the velocity
data is edge-centered (the MAC grid), the projection is cell-centered.
For the HG projection, since the velocity data is cell-centered, the
projection is node-centered. The
multigrid solver performs a number of V-cycles until the residual
drops by 10-12 orders-of-magnitude. There are several options that
affect how the multigrid solver behaves, which we describe below.
More detail on the multigrid solvers is given in Chapter <a class="reference external" href="#ch:mg">[ch:mg]</a>.</p>
</div>
<div class="section" id="multilevel-and-refinement-criteria">
<h2>Multilevel and Refinement Criteria<a class="headerlink" href="#multilevel-and-refinement-criteria" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="particles">
<span id="arch-sec-particles"></span><h2>Particles<a class="headerlink" href="#particles" title="Permalink to this headline">¶</a></h2>
<p>MAESTRO has support for Lagrangian particles that are passively
advected with the velocity field. These are useful for diagnostics
and post-processing. To use particles, particles must be seeded into
the domain by writing a problem-specific init_particles.f90
routine. This routine is called at the start of the simulation. The
init_particles routines add particles at specific locations by
calling the particle_module’s add routine when a given
criteria is met by the fluid state.</p>
<p>When you run the code, particles are enabled by setting
use_particles = T. At the end of each timestep the locations of
all the particles are written out into a series of files called
timestamp_NN, where NN is the CPU number on which the
particle <em>currently</em> resides. Particles are always kept on the
processor containing the state data corresponding to their present
location. Several bits of associated data (density, temperature, and
mass fractions) are stored along with the particle ID and position.</p>
<p>Some simple python scripts allow for the plotting of the particle
positions. See § <a class="reference external" href="#analysis:sec:particles">[analysis:sec:particles]</a> for details.</p>
</div>
<div class="section" id="regression-testing">
<h2>Regression Testing<a class="headerlink" href="#regression-testing" title="Permalink to this headline">¶</a></h2>
<p>There is an extensive regression test suite for AMReX that works with
MAESTRO. Full details, and a sample MAESTRO configuration file are
provided in the AMReX User’s Guide and source.</p>
<dl class="footnote brackets">
<dt class="label" id="id15"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>Spherical geometry
only exists for 3-d. This is a design decision—convection is 3-d.
You can however run as an octant</p>
</dd>
<dt class="label" id="id16"><span class="brackets"><a class="fn-backref" href="#id2">2</a></span></dt>
<dd><p>Note: many more compatible routines are available in the separate Microphysics git repo</p>
</dd>
<dt class="label" id="id17"><span class="brackets"><a class="fn-backref" href="#id7">3</a></span></dt>
<dd><p>Microphysics is
available at <a class="reference external" href="https://github.com/starkiller-astro/Microphysics">https://github.com/starkiller-astro/Microphysics</a>. MAESTRO will
find it via the MICROPHYSICS_HOME environment variable</p>
</dd>
<dt class="label" id="id18"><span class="brackets"><a class="fn-backref" href="#id12">4</a></span></dt>
<dd><p>Note: an older interface to the EOS exists, but is
deprecated. In this mode, the eos_old_interface module declares
the variables that need appear in the old-style eos call
argument list. MAESTRO routines use these module variables in the
EOS call to avoid having to declare each quantity in each routine
that calls the EOS. Most code has been updated to use the new interface.</p>
</dd>
</dl>
<p>1D base state and the full Cartesian state. (Left) For multi-level
problems in planar geometry, we force a direct alignment between the
radial array cell centers and the Cartesian grid cell centers by
allowing the radial base state spacing to change with space and
time. (Right) For multi-level problems in spherical geometry, since
there is no direct alignment between the radial array cell centers
and the Cartesian grid cell centers, we choose to fix the radial
base state spacing across levels. Figure taken
from <a href="#id19"><span class="problematic" id="id20">:raw-latex:`\cite{multilevel}`</span></a>.| image:: archfigpath/base_grid</p>
<blockquote>
<div><dl class="field-list simple">
<dt class="field-odd">height</dt>
<dd class="field-odd"><p>2in</p>
</dd>
</dl>
</div></blockquote>
<p>1D base state and the full Cartesian state. (Left) For multi-level
problems in planar geometry, we force a direct alignment between the
radial array cell centers and the Cartesian grid cell centers by
allowing the radial base state spacing to change with space and
time. (Right) For multi-level problems in spherical geometry, since
there is no direct alignment between the radial array cell centers
and the Cartesian grid cell centers, we choose to fix the radial
base state spacing across levels. Figure taken
from <a href="#id21"><span class="problematic" id="id22">:raw-latex:`\cite{multilevel}`</span></a>.| image:: archfigpath/base_spherical</p>
<blockquote>
<div><dl class="field-list simple">
<dt class="field-odd">height</dt>
<dd class="field-odd"><p>2in</p>
</dd>
</dl>
</div></blockquote>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="param_intro.html" class="btn btn-neutral float-right" title="Runtime Parameters" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="common_parameters.html" class="btn btn-neutral float-left" title="Common Runtime Parameters" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, MAESTROeX development tem

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>